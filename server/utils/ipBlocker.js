const fs = require('fs');
const path = require('path');
const { SecurityLogger, getClientIP } = require('./securityLogger');

/**
 * IP blocking middleware based on block list generated by log analysis
 */
class IPBlocker {
  constructor() {
    this.blockListPath = path.join(__dirname, '../logs/ip_blocklist.json');
    this.blockedIPs = new Set();
    this.lastUpdate = 0;
    this.updateInterval = 5 * 60 * 1000; // 5 minutes
    this.isTestMode = process.env.NODE_ENV === 'test';

    // Load initial list except in test mode
    if (!this.isTestMode) {
      this.updateBlockList();
    }
  }

  /**
   * Updates the list of blocked IPs from file
   */
  updateBlockList() {
    try {
      if (fs.existsSync(this.blockListPath)) {
        const stats = fs.statSync(this.blockListPath);
        const fileTime = stats.mtime.getTime();
        // Only reload if file has been modified
        if (fileTime > this.lastUpdate) {
          const blockListData = JSON.parse(fs.readFileSync(this.blockListPath, 'utf8'));
          this.blockedIPs = new Set(blockListData.ips || []);
          this.lastUpdate = fileTime;
          console.log(`Block list updated: ${this.blockedIPs.size} IP(s) blocked`);
        }
      }
    } catch (error) {
      console.error('Error updating block list:', error);
    }
  }

  /**
   * Adds an IP to the block list
   */
  blockIP(ip, reason = 'Manual block') {
    this.blockedIPs.add(ip);
    this.saveBlockList(reason);
  }

  /**
   * Removes an IP from the block list
   */
  unblockIP(ip) {
    this.blockedIPs.delete(ip);
    this.saveBlockList('Manual unblock');
  }

  /**
   * Saves the current block list
   */
  saveBlockList(reason = 'Updated block list') {
    try {
      const blockListData = {
        timestamp: new Date().toISOString(),
        reason: reason,
        ips: Array.from(this.blockedIPs),
        count: this.blockedIPs.size
      };      fs.writeFileSync(this.blockListPath, JSON.stringify(blockListData, null, 2));
      this.lastUpdate = Date.now();
    } catch (error) {
      console.error('Error saving block list:', error);
    }
  }

  /**
   * Checks if an IP is blocked
   */
  isBlocked(ip) {
    // Don't block in test mode
    if (this.isTestMode) {
      return false;
    }

    // Update list periodically
    if (Date.now() - this.lastUpdate > this.updateInterval) {
      this.updateBlockList();
    }

    return this.blockedIPs.has(ip);
  }

  /**
   * Express middleware to block IPs
   */
  middleware() {    return (req, res, next) => {
      const clientIP = getClientIP(req);
      if (this.isBlocked(clientIP)) {
        // Log blocked IP access attempt
        SecurityLogger.logRateLimitExceeded(req, 0, 0); // Reuse this log type
        // Manually add CORS headers for blocked IPs
        res.header('Access-Control-Allow-Origin', 'https://scolarite.polytech.univ-nantes.fr');
        res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
        res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, X-GestNote-Signature');
        res.header('Access-Control-Allow-Credentials', 'true');
        return res.status(403).json({ 
          error: 'Access forbidden',
          message: 'Your IP address has been blocked due to suspicious activity.'
        });
      }
      next();
    };
  }

  /**
   * Statistics on blocked IPs
   */
  getStats() {
    return {
      blockedCount: this.blockedIPs.size,
      lastUpdate: new Date(this.lastUpdate).toISOString(),
      blockedIPs: Array.from(this.blockedIPs)
    };
  }
}

// Singleton instance
const ipBlocker = new IPBlocker();

module.exports = {
  IPBlocker,
  ipBlocker
};
